.\" Automatically generated by Pod::Man v1.3, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Class 3"
.TH Class 3 "2002-08-21" "perl v5.6.1" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Exception::Class \- A module that allows you to declare real exception classes in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Exception::Class
\&      ( 'MyException',
.Ve
.Vb 2
\&        'AnotherException' =>
\&        { isa => 'MyException' },
.Ve
.Vb 3
\&        'YetAnotherException' =>
\&        { isa => 'AnotherException',
\&          description => 'These exceptions are related to IPC' },
.Ve
.Vb 4
\&        'ExceptionWithFields' =>
\&        { isa => 'YetAnotherException',
\&          fields => [ 'grandiosity', 'quixotic' ] },
\&      );
.Ve
.Vb 2
\&  # try
\&  eval { MyException->throw( error => 'I feel funny.'; };
.Ve
.Vb 5
\&  # catch
\&  if ( $@->isa('MyException') )
\&  {
\&     warn $@->error, "\en, $@->trace->as_string, "\en";
\&     warn join ' ',  $@->euid, $@->egid, $@->uid, $@->gid, $@->pid, $@->time;
.Ve
.Vb 17
\&     exit;
\&  }
\&  elsif ( $@->isa('ExceptionWithFields') )
\&  {
\&     if ( $@->quixotic )
\&     {
\&         do_something_wacky();
\&     }
\&     else
\&     {
\&         do_something_sane();
\&     }
\&  }
\&  else
\&  {
\&     $@->rethrow;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Exception::Class allows you to declare exception hierarchies in your
modules in a \*(L"Java\-esque\*(R" manner.
.PP
It features a simple interface allowing programmers to 'declare'
exception classes at compile time.  It also has a base exception
class, Exception::Class::Base, that can be easily extended.
.PP
It is designed to make structured exception handling simpler and
better by encouraging people to use hierarchies of exceptions in their
applications, as opposed to a single catch-all exception class.
.PP
This module does not implement any try/catch syntax.  Please see the
\&\*(L"\s-1OTHER\s0 \s-1EXCEPTION\s0 \s-1MODULES\s0 (try/catch syntax)\*(R" section for more
information on how to get this syntax.
.SH "DECLARING EXCEPTION CLASSES"
.IX Header "DECLARING EXCEPTION CLASSES"
Importing \f(CW\*(C`Exception::Class\*(C'\fR allows you to automagically create
\&\f(CW\*(C`Exception::Class::Base\*(C'\fR subclasses.  You can also create subclasses
via the traditional means of defining your own subclass with \f(CW@ISA\fR.
These two methods may be easily combined, so that you could subclass
an exception class defined via the automagic import, if you desired
this.
.PP
The syntax for the magic declarations is as follows:
.PP
\&'\s-1MANDATORY\s0 \s-1CLASS\s0 \s-1NAME\s0' => \e%optional_hashref
.PP
The hashref may contain the following options:
.IP "\(bu isa" 4
.IX Item "isa"
This is the class's parent class.  If this isn't provided then the
class name in \f(CW$Exception::Class::BASE_EXC_CLASS\fR is assumed to be
the parent (see below).
.Sp
This parameter lets you create arbitrarily deep class hierarchies.
This can be any other \f(CW\*(C`Exception::Class::Base\*(C'\fR subclass in your
declaration \fIor\fR a subclass loaded from a module.
.Sp
To change the default exception class you will need to change the
value of \f(CW$Exception::Class::BASE_EXC_CLASS\fR \fIbefore\fR calling \f(CW\*(C`import\*(C'\fR.
To do this simply do something like this:
.Sp
\&\s-1BEGIN\s0 { \f(CW$Exception::Class::BASE_EXC_CLASS\fR = 'SomeExceptionClass'; }
.Sp
If anyone can come up with a more elegant way to do this please let me
know.
.Sp
\&\s-1CAVEAT:\s0 If you want to automagically subclass an
\&\f(CW\*(C`Exception::Class::Base\*(C'\fR subclass loaded from a file, then you
\&\fImust\fR compile the class (via use or require or some other magic)
\&\fIbefore\fR you import \f(CW\*(C`Exception::Class\*(C'\fR or you'll get a compile time
error.
.IP "\(bu fields" 4
.IX Item "fields"
This allows you to define additional attributes for your exception
class.  Any field you define can be passed to the \f(CW\*(C`throw\*(C'\fR or \f(CW\*(C`new\*(C'\fR
methods as additional parameters for the constructor.  In addition,
your exception object will have an accessor method for the fields you
define.
.Sp
This parameter can be either a scalar (for a single field) or an array
reference if you need to define multiple fields.
.Sp
Fields will be inherited by subclasses.
.IP "\(bu description" 4
.IX Item "description"
Each exception class has a description method that returns a fixed
string.  This should describe the exception \fIclass\fR (as opposed to
any particular exception object).  This may be useful for debugging if
you start catching exceptions you weren't expecting (particularly if
someone forgot to document them) and you don't understand the error
messages.
.PP
The \f(CW\*(C`Exception::Class\*(C'\fR magic attempts to detect circular class
hierarchies and will die if it finds one.  It also detects missing
links in a chain, for example if you declare Bar to be a subclass of
Foo and never declare Foo.
.SH "Exception::Class::Base CLASS METHODS"
.IX Header "Exception::Class::Base CLASS METHODS"
.IP "\(bu Trace($true_or_false)" 4
.IX Item "Trace($true_or_false)"
Each \f(CW\*(C`Exception::Class::Base\*(C'\fR subclass can be set individually to
include a a stracktrace when the \f(CW\*(C`as_string\*(C'\fR method is called.  The
default is to not include a stacktrace.  Calling this method with a
value changes this behavior.  It always returns the current value
(after any change is applied).
.Sp
This value is inherited by any subclasses.  However, if this value is
set for a subclass, it will thereafter be independent of the value in
\&\f(CW\*(C`Exception::Class::Base\*(C'\fR.
.Sp
This is a class method, not an object method.
.ie n .IP "\(bu throw( $message )" 4
.el .IP "\(bu throw( \f(CW$message\fR )" 4
.IX Item "throw( $message )"
.PD 0
.ie n .IP "\(bu throw( message => $message )" 4
.el .IP "\(bu throw( message => \f(CW$message\fR )" 4
.IX Item "throw( message => $message )"
.ie n .IP "\(bu throw( error => $error )" 4
.el .IP "\(bu throw( error => \f(CW$error\fR )" 4
.IX Item "throw( error => $error )"
.PD
This method creates a new \f(CW\*(C`Exception::Class::Base\*(C'\fR object with the
given error message.  If no error message is given, \f(CW$!\fR is used.  It
then die's with this object as its argument.
.Sp
This method also takes a \f(CW\*(C`show_trace\*(C'\fR parameter which indicates
whether or not the particular exception object being created should
show a stacktrace when its \f(CW\*(C`as_string\*(C'\fR method is called.  This
overrides the value of \f(CW\*(C`Trace\*(C'\fR for this class if it is given.
.Sp
If only a single value is given to the constructor it is assumed to be
the message parameter.
.Sp
Additional keys corresponding to any fields defined for the particular
exception subclass will also be accepted.
.IP "\(bu new" 4
.IX Item "new"
This method takes the same parameters as \f(CW\*(C`throw\*(C'\fR, but instead of
dying simply returns a new exception object.
.IP "\(bu description" 4
.IX Item "description"
Returns the description for the given \f(CW\*(C`Exception::Class::Base\*(C'\fR
subclass.  The \f(CW\*(C`Exception::Class::Base\*(C'\fR class's description is
\&\*(L"Generic exception\*(R" (this may change in the future).  This is also an
object method.
.SH "Exception::Class::Base OBJECT METHODS"
.IX Header "Exception::Class::Base OBJECT METHODS"
.IP "\(bu rethrow" 4
.IX Item "rethrow"
Simply dies with the object as its sole argument.  It's just syntactic
sugar.  This does not change any of the object's attribute values.
However, it will cause \f(CW\*(C`caller\*(C'\fR to report the die as coming from
within the \f(CW\*(C`Exception::Class::Base\*(C'\fR class rather than where rethrow
was called.
.Sp
Of course, you always have access to the original stacktrace for the
exception object.
.IP "\(bu message" 4
.IX Item "message"
.PD 0
.IP "\(bu error" 4
.IX Item "error"
.PD
Returns the error/message associated with the exception.
.IP "\(bu pid" 4
.IX Item "pid"
Returns the pid at the time the exception was thrown.
.IP "\(bu uid" 4
.IX Item "uid"
Returns the real user id at the time the exception was thrown.
.IP "\(bu gid" 4
.IX Item "gid"
Returns the real group id at the time the exception was thrown.
.IP "\(bu euid" 4
.IX Item "euid"
Returns the effective user id at the time the exception was thrown.
.IP "\(bu egid" 4
.IX Item "egid"
Returns the effective group id at the time the exception was thrown.
.IP "\(bu time" 4
.IX Item "time"
Returns the time in seconds since the epoch at the time the exception
was thrown.
.IP "\(bu package" 4
.IX Item "package"
Returns the package from which the exception was thrown.
.IP "\(bu file" 4
.IX Item "file"
Returns the file within which the exception was thrown.
.IP "\(bu line" 4
.IX Item "line"
Returns the line where the exception was thrown.
.IP "\(bu trace" 4
.IX Item "trace"
Returns the trace object associated with the object.
.IP "\(bu as_string" 4
.IX Item "as_string"
Returns a string form of the error message (something like what you'd
expect from die).  If the class or object is set to show traces then
then the full trace is also included.  The result looks like
\&\f(CW\*(C`Carp::confess\*(C'\fR.
.IP "\(bu full_message" 4
.IX Item "full_message"
Called by the \f(CW\*(C`as_string\*(C'\fR method to get the message.  By default,
this is the same as calling the \f(CW\*(C`message\*(C'\fR method, but may be
overridden by a subclass.  See below for details.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
The \f(CW\*(C`Exception::Class::Base\*(C'\fR object is overloaded so that
stringification produces a normal error message.  It just calls the
as_string method described above.  This means that you can just
\&\f(CW\*(C`print $@\*(C'\fR after an eval and not worry about whether or not its an
actual object.  It also means an application or module could do this:
.PP
.Vb 1
\& $SIG{__DIE__} = sub { Exception::Class::Base->throw( error => join '', @_ ); };
.Ve
and this would probably not break anything (unless someone was
expecting a different type of exception object from \f(CW\*(C`die\*(C'\fR).
.SH "OVERRIDING THE as_string METHOD"
.IX Header "OVERRIDING THE as_string METHOD"
By default, the \f(CW\*(C`as_string\*(C'\fR method simply returns the value
\&\f(CW\*(C`message\*(C'\fR or \f(CW\*(C`error\*(C'\fR param plus a stack trace, if the class's
\&\f(CW\*(C`Trace\*(C'\fR method returns a true value or \f(CW\*(C`show_trace\*(C'\fR was set when
creating the exception.
.PP
However, once you add new fields to a subclass, you may want to
include those fields in the stringified error.
.PP
Inside the \f(CW\*(C`as_string\*(C'\fR method, the message (non\-stack trace) portion
of the error is generated by calling the \f(CW\*(C`full_message\*(C'\fR method.  This
can be easily overridden.  For example:
.PP
.Vb 3
\&  sub full_message
\&  {
\&      my $self = shift;
.Ve
.Vb 1
\&      my $msg = $self->message;
.Ve
.Vb 1
\&      $msg .= " and foo was " . $self->foo;
.Ve
.Vb 2
\&      return $msg;
\&  }
.Ve
.SH "USAGE RECOMMENDATION"
.IX Header "USAGE RECOMMENDATION"
If you're creating a complex system that throws lots of different
types of exceptions, consider putting all the exception declarations
in one place.  For an app called Foo you might make a
\&\f(CW\*(C`Foo::Exceptions\*(C'\fR module and use that in all your code.  This module
could just contain the code to make \f(CW\*(C`Exception::Class\*(C'\fR do its
automagic class creation.  Doing this allows you to more easily see
what exceptions you have, and makes it easier to keep track of them.
.PP
This might look something like this:
.PP
.Vb 1
\&  package Foo::Bar::Exceptions;
.Ve
.Vb 2
\&  use Exception::Class ( Foo::Bar::Exception::Senses =>
\&                        { description => 'sense-related exception' },
.Ve
.Vb 4
\&                         Foo::Bar::Exception::Smell =>
\&                         { isa => 'Foo::Bar::Exception::Senses',
\&                           fields => 'odor',
\&                           description => 'stinky!' },
.Ve
.Vb 4
\&                         Foo::Bar::Exception::Taste =>
\&                         { isa => 'Foo::Bar::Exception::Senses',
\&                           fields => [ 'taste', 'bitterness' ],
\&                           description => 'like, gag me with a spoon!' },
.Ve
.Vb 1
\&                         ... );
.Ve
You may want to create a real module to subclass
\&\f(CW\*(C`Exception::Class::Base\*(C'\fR as well, particularly if you want your
exceptions to have more methods.
.SH "OTHER EXCEPTION MODULES (try/catch syntax)"
.IX Header "OTHER EXCEPTION MODULES (try/catch syntax)"
If you are interested in adding try/catch/finally syntactic sugar to
your code then I recommend you check out U. Arun Kumar's \f(CW\*(C`Error.pm\*(C'\fR
module, which implements this syntax.  It also includes its own base
exception class, \f(CW\*(C`Error::Simple\*(C'\fR.
.PP
If you would prefer to use the \f(CW\*(C`Exception::Class::Base\*(C'\fR class
included with this module, you'll have to add this to your code
somewhere:
.PP
.Vb 1
\&  push @Exception::Class::Base::ISA, 'Error';
.Ve
It's a hack but apparently it works.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Rolsky, <autarch@urth.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::StackTrace \- used by this module to create stack traces
.PP
Error.pm \- implements try/catch in Perl.  Also provides an exception
base class.
.PP
Test::Exception \- a module that helps you test exception based code.
.PP
Numerous other modules/frameworks seem to have their own exception
classes (\s-1SPOPS\s0 and Template Toolkit, to name two) but none of these
seem to be designed for use outside of these packages.
